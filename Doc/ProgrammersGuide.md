Q: What does a zone look like? 
A: In the most basic sense, it is an enumerable collection of lights. A light, as defined in this application, is nothing more than a contract - an interface - defined as ILogicalRGBLight. This tells us a few things about what the light is and what it can do. First, it tells us that the interface expects an RGB color to be representable by its implementation, but if a light doesn't support full RGB, the implementation can throw an exception during its API calls when the RGB values are invalid. It's important to note that this is a logical representation of a light. The implementation of this interface does not require the implementer to interact with the physical light. That is the job of the lighting controller (ILightingController). ILogicalRGBLight has three methods that it expects the subclass to define: 

1. bool SetColor(Color color) - Expects the subclass to define how to set the color of the given light. Note that this does not mean how to physically set the color of the light, but how to set it in the logical view of the light. There is a logical view of the lights and a physical view. The logical view acts as a filter to filter out invalid values of color, for example (or other kinds of filtering). If the subclass of this interface is used to represent an incandescent light, which can only display lights of a certain color (yellowish to whiteish), then the SetColor method can be programmed to return false or throw an error when the requested color is not in the range of colors that can be produced on the light. In this way, we do need to know something about the physical lights that the subclass will represent, but this interface's implementation does not need to know how to physically change the color of the light. That will be done using the physical definition of the light in terms of a specific controller as we will see in a bit.

2. int LogicalIndex - This property defines the address of the light in the logical view. This is useful in things like sorting the lights. This number is different from the physical index that will be defined in the concrete implementation of the light. The physical index will be specific to the lighting controller, but the logical index is not.

3. Color GetColor() - Expects the subclass to define how to get the current color of the light.

Now let's look at an implementation of this interface called LED. The LED class represents a single LED in a zone. The way I've programmed this, it needs to implement interfaces for each type of physical representation of a light that it can be output on. So for example, it implements IFadeCandyPixel which requires an instance of FadeCandyPixel which contains all information required by the FadeCandyController to output this light to a FadeCandy board. IFadeCandyPixel is required to output the light using FadeCandyController because IFadeCandyPixel is the PixelType of FadeCandyController. To create an instance of an LED that needs to be output on FadeCandy, it needs the physical index of the LED on the FadeCandy which is passed in through the constructor. Then the color of the LED is set using SetColor. This changes the color of the logical view which is then sent to the lighting controller using FadeCandyController.SendLEDs method.

Zones need to created by the user by subclassing the Zone class based on their lighting setup. For a FadeCandy zone, subclass the FadeCandyZone class, which sets the zone's lighting controller to FadeCandyController. Your custom zone classes can be created in an external assembly by creating a new C# class library project. This assembly needs to be stored in the folder specified by the ZonesDLLFolder configuration property. This folder will be scanned during initialization and those zones will be available to the zone programs to be manipulated.
