ZoneLighting is a framework to create pixel-based lighting for your home or office (or any other space). It abstracts out the logical view of the lights in "zones", which can each run a "zone program". Zones can contain other zones. These zones can be represented on any configuration of physical lights. The program running on the zone must take the physical configuration into account. Currently the application supports LEDs, but the application can be extended to use any physical light whose color can be represented as an ARGB value.

I believe that the best way to explain such an abstract concept is to show an example of how it is intended to be used. So I will do just that:

I created this application to allow for creating some mood lighting in my basement. The lighting is laid out as such:



[------------------]												[-------------------]
[                  ]												[					]
[    Left Wing     ]												[	  Right Wing	]
[                  ]												[					]
[------------------]												[-------------------]

			\																/
			  \															  /	
                \														/
                  \													  /	
                    \												/
                      \											  /
                        \										/
                          \									  /
							\	[-------------------------] /
							  \	[						  ]
								[		FadeCandy 		  ]
								[	Lighting Controller   ]
								[						  ]
								[-------------------------]



Left Wing and Right Wing are sets of lights that sit on the left and right side of my computer monitor, respectively. They are both cut from a long strip of WS2812s. WS2812 is an electronic component that is a combination of an RGB LED and a driver chip that handles PWM, I/O buffering and propagation, timing issues, and other details that are required for a high-level control of an RGB LED or a series of RGB LEDs. 

Note: WS2812s are are sometimes (incorrectly) referred to as "WS2811". Even though for most practical purposes the names WS2811 and WS2812 are interchangeable, it's important to realize that the WS2811 (http://www.adafruit.com/datasheets/WS2811.pdf) is the name for the driver chip that drives the RGB LED, and WS2812 (http://www.adafruit.com/datasheets/WS2812.pdf) is the name for the entire component, including the LED and the driver chip. But since the WS2811 driver chip is essentially useless without the LED, the name "WS2811" is many times used interchangeably with WS2812. Many vendors sell WS2812s as WS2811, so if searching vendor sites to buy the WS2812, try searching for WS2811 also. The Adafruit product known as NeoPixel is the same as the WS2812 rebranded for Adafruit.

This project was started as an abstraction on top of the FadeCandy board (https://github.com/scanlime/fadecandy). FadeCandy is a product created by GitHub user scanlime. It consists of a physical hardware board that is able to control 512 WS2812s as 8 strips of 64 WS2812s and the software component which consists of a program called FCServer that connects to the physical board over USB and listens for requests over WebSockets in the format formalized by the Open Packet Control protocol (which was also created by scanlime). FCServer redirects these WebSocket requests to the physical FadeCandy board. These may be requests to change the color of the lights or administrative requests like enabling/disabling dithering or interpolation. I wanted to create a software layer that abstracts out the entire FadeCandy stack as a generic lighting controller. This generalization is intended to allow controlling non-WS2812 RGB LED strips (like the LPD8806 which needs manual PWM and requires a clock signal). This also allows multi-layered configurations and to "transfer" a zone configuration to a different physical configuration without changing anything in the physical connectivity layer. In short, this application heavily enforces separation of concerns by using a layered architecture.
	
Currently, the application only supports FadeCandy as the lighting controller and what I call a FadeCandyPixel as the physical unit of a "pixel". But I've designed this project with the intention of other people extending it. To add a new lighting controller, all one needs to do is extend the abstract LightingController class. To add new types of lights, all that's required is to extend the abstract PhysicalRGBLight class. 

The FadeCandyController class is implemented as a singleton, simply because at the time of writing this code, it was anticipated that only a single FadeCandy board will be used with this program. If someone anticipates that using more than one board is necessary, it's very easy to convert it from a singleton to a non-singleton class. The instances will live inside the ZoneLightingManager class.

Speaking of ZoneLightingManager (ZLM), it is worth talking a bit about this class and its function. This is what you can call the "runner" class for the entire application. All high-level operations like initializing/uninitializing zone programs, zones, or lighting controllers can be done using this class. It is implemented as a singleton and to access the singleton instance, use ZoneLightingManager.Instance (this is the practice followed throughout the entire application for accessing singleton instances for any given class). ZLM is also responsible for adding/removing zone data. Currently it is adding data in the LoadSampleZoneData() method based on the configuration I have in the ASCII diagram above. In LoadSampleZoneData(), it adds two zones that are to be controlled by a FadeCandy board, leftWingZone and rightWingZone. These zones are added to a member of ZLM called Zones, which is a list of Zones that ZLM can manage. When the Initialize() method is called on ZLM, it initializes all zones contained in the member Zones. This initialization entails selecting a zone program for each zone and starting it with some parameters.

What exactly is a zone program? A zone program is essentially a piece of code (program) that can output anything it needs to a zone's lights. An example of a zone program is some code that loops the colors of a rainbow on a zone (or any other collection of colors). Another example is a program that checks your email every so often and blinks the lights in a zone in a certain pattern when you get a new email. Another example is a program that just "scrolls" a dot across the lights in a zone such by turning the appropriate lights on and off such that a "dot" appears to be moving across the lights of that zone. So really, a zone program in this sense is any program that outputs a lighting pattern on a given zone. This pattern may or may not be based on external stimuli.